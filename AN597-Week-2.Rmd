---
title: "AN597-Week-2"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

# Coding Challenges for Module 4
install.packages("stringr")

### CHALLENGE 1
# Creating a 1 word character vector from the first line in Ulysses
my_charvect<- c("Stately,", "plump", "Buck", "Mulligan", "came", "from", "the", "stairhead,", "bearing", "a", "bowl", "of", "lather", "on", "which", "a", "mirror", "and", "a", "razor", "lay", "crossed")

#Tried this... but "from" must be a finate number NOT a character
my_charvect[seq(from = "Stately", to = "crossed", by = 3)]

## I couldn't think of one command to use to pull every 3rd word so I decided to create a matrix with every 3rd word in the 3rd column
#Creating a character matrix with 3 columns so that I can only look at the 3rd column for all the third words; making byrow= TRUE so that the words go in order across the rows
my_charvect_matrix <- matrix(data= my_charvect, nrow=8,ncol=3, byrow = TRUE)

# extracting only the words in column 3 (all rows) in order to see the third words in the vector
thirdword <- m[1:7, 3]

#This command also works but I don't want to use it becuase it includes all of the rows; R has repeated the character vector again in order to fill up the entire row (ex: "plump" is repeated using this code)
x2<- m[,3]

### CHALLENGE 2
m <- matrix(data=1:80,nrow=8,ncol=10,byrow=FALSE)
m

#extracting the 2nd, 3rd, and 6th columns
## this one gave me some trouble: I tried x<- m[,(2,3,6)], x<- m[,2,3,6], x<- m[,2], m[,3], m[,6], and x<- m[1:8,2] m[1:8,3] m[1:8,6] before I realized I needed to use c()
x<- m[,c(2,3,6)]

#extracting the 6th-8th row
x<- m[6:8,]
x

#extracting the elements from row 2, column 2 to row 6, column 9
x<- m[2,2]:m[6,9]
x

### CHALLENGE 3
#Constructing a 4-dimensional, 400 element array.. EEKK
a <- array(data=400:1, dim=c(10,10,4))
a <- array(data=400:1, dim=c(5,5,4,4))

a[1, 1, 1, 2]

#Overwriting
#makes the value of m[7,1] labeled 564
m[7,1] <- 564
#makes all of the numbers in column 8 = 2
m[,8] <- 2
#makes all of the numbers within those rows/columns = 1
m[2:5,4:8] <- 1
#makes all of the numbers within those rows/colums = 20,19,18,17 by row
m[2:5,4:8] <- c(20,19,18,17)
#created a matrix using 20:1 descending by row
m[2:5,4:8] <- matrix(data = c(20:1), nrow=4,ncol=5,byrow=TRUE)
#makes column 8 go back to "a", "b" values 
m[,8] <- c("a","b")

#Lists and Data Frames
s <- c("this","is","a","vector","of","strings")
m <- matrix(data=1:40, nrow=5, ncol=8)
b<- FALSE
l <- list(s, m, b)
#to access an element within the list use double brackets
l[[2]]
# to access elements within an element in the list
l[[2]][2,6]
#To reference/extract multiple elements from a list, you would use single bracket notation, which would itself return a list. This is called “list slicing”
l[1:2]
l[c(1,3)]
#use str() to provide details about the three elements
str(l)
#adding names to the elements within the list
names(l) <- c("string", "matrix", "logical")
names(l)
#use the name of the element to refer to it specifically
l$string
l$matrix[3,5]
